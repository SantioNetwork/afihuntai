"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _plugin() {
  const data = require("@parcel/plugin");
  _plugin = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _jsonSourcemap() {
  const data = require("@mischnic/json-sourcemap");
  _jsonSourcemap = function () {
    return data;
  };
  return data;
}
function _contentSecurityPolicyParser() {
  const data = _interopRequireDefault(require("content-security-policy-parser"));
  _contentSecurityPolicyParser = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@parcel/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _diagnostic() {
  const data = _interopRequireWildcard(require("@parcel/diagnostic"));
  _diagnostic = function () {
    return data;
  };
  return data;
}
var _schema = require("./schema");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const DEP_LOCS = [['icons'], ['browser_action', 'default_icon'], ['browser_action', 'default_popup'], ['page_action', 'default_icon'], ['page_action', 'default_popup'], ['action', 'default_icon'], ['action', 'default_popup'], ['background', 'scripts'], ['chrome_url_overrides'], ['devtools_page'], ['options_ui', 'page'], ['sandbox', 'pages'], ['side_panel', 'default_path'], ['sidebar_action', 'default_icon'], ['sidebar_action', 'default_panel'], ['storage', 'managed_schema'], ['theme', 'images', 'theme_frame'], ['theme', 'images', 'additional_backgrounds'], ['user_scripts', 'api_script']];
async function collectDependencies(asset, program, ptrs, hmrOptions) {
  var _program$browserActio, _program$background, _program$background2;
  const hot = Boolean(hmrOptions);
  const fs = asset.fs;
  const filePath = asset.filePath;
  const assetDir = _path().default.dirname(filePath);
  const isMV2 = program.manifest_version == 2;
  delete program.$schema;
  if (program.default_locale) {
    const locales = _path().default.join(assetDir, '_locales');
    let err = !(await fs.exists(locales)) ? 'key' : !(await fs.exists(_path().default.join(locales, program.default_locale, 'messages.json'))) ? 'value' : null;
    if (err) {
      throw new (_diagnostic().default)({
        diagnostic: [{
          message: 'Invalid Web Extension manifest',
          origin: '@parcel/transformer-webextension',
          codeFrames: [{
            filePath,
            codeHighlights: [{
              ...(0, _diagnostic().getJSONHighlightLocation)(ptrs['/default_locale'], err),
              message: (0, _diagnostic().md)`Localization ${err == 'value' ? 'file for ' + program.default_locale : 'directory'} does not exist: ${_path().default.relative(assetDir, _path().default.join(locales, program.default_locale))}`
            }]
          }]
        }]
      });
    }
    for (const locale of await fs.readdir(locales)) {
      if (await fs.exists(_path().default.join(locales, locale, 'messages.json'))) {
        asset.addURLDependency(`_locales/${locale}/messages.json`, {
          needsStableName: true,
          pipeline: 'raw'
        });
      }
    }
  }
  if (program.content_scripts) {
    for (let i = 0; i < program.content_scripts.length; ++i) {
      const sc = program.content_scripts[i];
      for (const k of ['css', 'js']) {
        const assets = sc[k] || [];
        for (let j = 0; j < assets.length; ++j) {
          assets[j] = asset.addURLDependency(assets[j], {
            bundleBehavior: 'isolated',
            loc: {
              filePath,
              ...(0, _diagnostic().getJSONSourceLocation)(ptrs[`/content_scripts/${i}/${k}/${j}`], 'value')
            }
          });
        }
      }
      if (hot && sc.js && sc.js.length) {
        sc.js.push(asset.addURLDependency('./runtime/autoreload.js', {
          resolveFrom: __filename
        }));
      }
    }
  }
  if (program.dictionaries) {
    for (const dict in program.dictionaries) {
      const dictFile = program.dictionaries[dict];
      if (_path().default.extname(dictFile) != '.dic') {
        throw new (_diagnostic().default)({
          diagnostic: [{
            message: 'Invalid Web Extension manifest',
            origin: '@parcel/transformer-webextension',
            codeFrames: [{
              filePath,
              codeHighlights: [{
                ...(0, _diagnostic().getJSONHighlightLocation)(ptrs[`/dictionaries/${dict}`], 'value'),
                message: 'Dictionaries must be .dic files'
              }]
            }]
          }]
        });
      }
      const loc = {
        filePath,
        ...(0, _diagnostic().getJSONSourceLocation)(ptrs[`/dictionaries/${dict}`], 'value')
      };
      program.dictionaries[dict] = asset.addURLDependency(dictFile, {
        needsStableName: true,
        loc
      });
      asset.addURLDependency(dictFile.slice(0, -4) + '.aff', {
        needsStableName: true,
        loc
      });
    }
  }
  const browserActionName = isMV2 ? 'browser_action' : 'action';
  if ((_program$browserActio = program[browserActionName]) !== null && _program$browserActio !== void 0 && _program$browserActio.theme_icons) {
    for (let i = 0; i < program[browserActionName].theme_icons.length; ++i) {
      const themeIcon = program[browserActionName].theme_icons[i];
      for (const k of ['light', 'dark']) {
        const loc = (0, _diagnostic().getJSONSourceLocation)(ptrs[`/${browserActionName}/theme_icons/${i}/${k}`], 'value');
        themeIcon[k] = asset.addURLDependency(themeIcon[k], {
          loc: {
            ...loc,
            filePath
          }
        });
      }
    }
  }
  if (program.web_accessible_resources) {
    let war = [];
    for (let i = 0; i < program.web_accessible_resources.length; ++i) {
      // TODO: this doesn't support Parcel resolution
      const currentEntry = program.web_accessible_resources[i];
      const files = isMV2 ? [currentEntry] : currentEntry.resources;
      let currentFiles = [];
      for (let j = 0; j < files.length; ++j) {
        const globFiles = (await (0, _utils().glob)(_path().default.join(assetDir, files[j]), fs, {})).map(fp => asset.addURLDependency(_path().default.relative(assetDir, fp), {
          bundleBehavior: 'isolated',
          needsStableName: true,
          loc: {
            filePath,
            ...(0, _diagnostic().getJSONSourceLocation)(ptrs[`/web_accessible_resources/${i}${isMV2 ? '' : `/resources/${j}`}`])
          }
        }));
        currentFiles = currentFiles.concat(globFiles);
      }
      if (isMV2) {
        war = war.concat(currentFiles);
      } else {
        currentEntry.resources = currentFiles;
        war.push(currentEntry);
      }
    }
    program.web_accessible_resources = war;
  }
  if (program.declarative_net_request) {
    var _program$declarative_, _program$declarative_2;
    const rrs = (_program$declarative_ = (_program$declarative_2 = program.declarative_net_request) === null || _program$declarative_2 === void 0 ? void 0 : _program$declarative_2.rule_resources) !== null && _program$declarative_ !== void 0 ? _program$declarative_ : [];
    rrs.forEach((resources, i) => {
      resources.path = asset.addURLDependency(resources.path, {
        pipeline: 'raw',
        loc: {
          filePath,
          ...(0, _diagnostic().getJSONSourceLocation)(ptrs[`/declarative_net_request/rule_resources/${i}/path`], 'value')
        }
      });
    });
  }
  for (const loc of DEP_LOCS) {
    const location = '/' + loc.join('/');
    if (!ptrs[location]) continue;
    let parent = program;
    for (let i = 0; i < loc.length - 1; ++i) {
      parent = parent[loc[i]];
    }
    const lastLoc = loc[loc.length - 1];
    const obj = parent[lastLoc];
    if (typeof obj == 'string') parent[lastLoc] = asset.addURLDependency(obj, {
      bundleBehavior: 'isolated',
      loc: {
        filePath,
        ...(0, _diagnostic().getJSONSourceLocation)(ptrs[location], 'value')
      },
      pipeline: _path().default.extname(obj) == '.json' ? 'raw' : undefined
    });else {
      for (const k of Object.keys(obj)) {
        obj[k] = asset.addURLDependency(obj[k], {
          bundleBehavior: 'isolated',
          loc: {
            filePath,
            ...(0, _diagnostic().getJSONSourceLocation)(ptrs[location + '/' + k], 'value')
          },
          pipeline: _path().default.extname(obj[k]) == '.json' ? 'raw' : undefined
        });
      }
    }
  }
  if ((_program$background = program.background) !== null && _program$background !== void 0 && _program$background.page) {
    program.background.page = asset.addURLDependency(program.background.page, {
      bundleBehavior: 'isolated',
      loc: {
        filePath,
        ...(0, _diagnostic().getJSONSourceLocation)(ptrs['/background/page'], 'value')
      }
    });
  } else if ((_program$background2 = program.background) !== null && _program$background2 !== void 0 && _program$background2.service_worker) {
    program.background.service_worker = asset.addURLDependency(program.background.service_worker, {
      bundleBehavior: 'isolated',
      loc: {
        filePath,
        ...(0, _diagnostic().getJSONSourceLocation)(ptrs['/background/service_worker'], 'value')
      },
      env: {
        context: 'service-worker',
        sourceType: program.background.type == 'module' ? 'module' : 'script'
      }
    });
  }
  if (hot) {
    var _program$content_scri;
    if (isMV2) {
      // To enable HMR, we must override the CSP to allow 'unsafe-eval'
      program.content_security_policy = cspPatchHMR(program.content_security_policy);
    } else {
      // Enable HMR for fetched localhost chunks
      const csp = program.content_security_policy || {};
      csp.extension_pages = cspPatchHMR(csp.extension_pages, `http://${(hmrOptions === null || hmrOptions === void 0 ? void 0 : hmrOptions.host) || 'localhost'}:*`);
      // Sandbox allows eval by default
      if (csp.sandbox) csp.sandbox = cspPatchHMR(csp.sandbox);
      program.content_security_policy = csp;
    }
    if (!program.background) {
      program.background = {};
    }
    if (program.background.page) {
      asset.meta.webextBGInsert = program.background.page;
    } else if (isMV2 || program.background.scripts) {
      if (!program.background.scripts) {
        program.background.scripts = [];
      }
      if (program.background.scripts.length == 0) {
        program.background.scripts.push(asset.addURLDependency('./runtime/default-bg.js', {
          resolveFrom: __filename
        }));
      }
      asset.meta.webextBGInsert = program.background.scripts[0];
    } else {
      if (!program.background.service_worker) {
        program.background.service_worker = asset.addURLDependency('./runtime/default-bg.js', {
          resolveFrom: __filename,
          env: {
            context: 'service-worker'
          }
        });
      }
      asset.meta.webextBGInsert = program.background.service_worker;
    }
    if (!program.permissions) program.permissions = [];
    if (!isMV2 && !program.permissions.includes('scripting')) {
      program.permissions.push('scripting');
    }
    const hostPerms = [...new Set((_program$content_scri = program.content_scripts) === null || _program$content_scri === void 0 ? void 0 : _program$content_scri.flatMap(sc => sc.matches))];
    if (isMV2) program.permissions = program.permissions.concat(hostPerms);else {
      if (!program.host_permissions) program.host_permissions = [];
      program.host_permissions = program.host_permissions.concat(hostPerms);
    }
  }
}
function cspPatchHMR(policy, insert) {
  let defaultSrc = "'self'";
  if (insert == null) {
    insert = "'unsafe-eval'";
    defaultSrc = "'self' blob: filesystem:";
  }
  if (policy) {
    const csp = (0, _contentSecurityPolicyParser().default)(policy);
    policy = '';
    if (!csp['script-src']) {
      csp['script-src'] = [defaultSrc];
    }
    if (!csp['script-src'].includes(insert)) {
      csp['script-src'].push(insert);
    }
    if (csp.sandbox && !csp.sandbox.includes('allow-scripts')) {
      csp.sandbox.push('allow-scripts');
    }
    for (const k in csp) {
      policy += `${k} ${csp[k].join(' ')};`;
    }
    return policy;
  } else {
    return `script-src ${defaultSrc} ${insert};` + `object-src ${defaultSrc};`;
  }
}
var _default = exports.default = new (_plugin().Transformer)({
  async transform({
    asset,
    options
  }) {
    var _asset$env$sourceMap$, _asset$env$sourceMap$2;
    // Set environment to browser, since web extensions are always used in
    // browsers, and because it avoids delegating extra config to the user
    asset.setEnvironment({
      context: 'browser',
      outputFormat: asset.env.outputFormat == 'commonjs' ? 'global' : asset.env.outputFormat,
      engines: {
        browsers: asset.env.engines.browsers
      },
      sourceMap: asset.env.sourceMap && {
        ...asset.env.sourceMap,
        // Inline source maps work most reliably on web extensions but allow users to overwrite
        inline: (_asset$env$sourceMap$ = asset.env.sourceMap.inline) !== null && _asset$env$sourceMap$ !== void 0 ? _asset$env$sourceMap$ : true,
        inlineSources: (_asset$env$sourceMap$2 = asset.env.sourceMap.inlineSources) !== null && _asset$env$sourceMap$2 !== void 0 ? _asset$env$sourceMap$2 : true
      },
      includeNodeModules: asset.env.includeNodeModules,
      sourceType: asset.env.sourceType,
      isLibrary: asset.env.isLibrary,
      shouldOptimize: asset.env.shouldOptimize,
      shouldScopeHoist: asset.env.shouldScopeHoist
    });
    const code = await asset.getCode();
    const parsed = (0, _jsonSourcemap().parse)(code);
    const data = parsed.data;

    // Not using a unified schema dramatically improves error messages
    let schema = _schema.VersionSchema;
    if (data.manifest_version === 3) {
      schema = _schema.MV3Schema;
    } else if (data.manifest_version === 2) {
      schema = _schema.MV2Schema;
    }
    _utils().validateSchema.diagnostic(schema, {
      data: data,
      source: code,
      filePath: asset.filePath
    }, '@parcel/transformer-webextension', 'Invalid Web Extension manifest');
    await collectDependencies(asset, data, parsed.pointers, options.hmrOptions);
    asset.setCode(JSON.stringify(data, null, 2));
    asset.meta.webextEntry = true;
    return [asset];
  }
});