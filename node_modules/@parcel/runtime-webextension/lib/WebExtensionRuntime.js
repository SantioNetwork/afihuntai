"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
function _plugin() {
  const data = require("@parcel/plugin");
  _plugin = function () {
    return data;
  };
  return data;
}
function _utils() {
  const data = require("@parcel/utils");
  _utils = function () {
    return data;
  };
  return data;
}
function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));
  _nullthrows = function () {
    return data;
  };
  return data;
}
function _fs() {
  const data = _interopRequireDefault(require("fs"));
  _fs = function () {
    return data;
  };
  return data;
}
function _path() {
  const data = _interopRequireDefault(require("path"));
  _path = function () {
    return data;
  };
  return data;
}
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const AUTORELOAD_BG = _fs().default.readFileSync(_path().default.join(__dirname, 'autoreload-bg.js'), 'utf8');
var _default = exports.default = new (_plugin().Runtime)({
  loadConfig({
    config
  }) {
    config.invalidateOnBuild();
  },
  async apply({
    bundle,
    bundleGraph,
    options
  }) {
    var _bundle$getMainEntry;
    if (!bundle.env.isBrowser() || bundle.env.isWorklet()) {
      return;
    }
    if (((_bundle$getMainEntry = bundle.getMainEntry()) === null || _bundle$getMainEntry === void 0 ? void 0 : _bundle$getMainEntry.meta.webextEntry) === true) {
      // Hack to bust packager cache when any descendants update
      const descendants = [];
      bundleGraph.traverseBundles(b => {
        descendants.push(b.id);
      }, bundle);
      return {
        filePath: __filename,
        code: JSON.stringify(descendants),
        isEntry: true
      };
    } else if (options.hmrOptions && bundle.type == 'js') {
      const manifest = bundleGraph.getBundles().find(b => {
        var _b$getMainEntry;
        return ((_b$getMainEntry = b.getMainEntry()) === null || _b$getMainEntry === void 0 ? void 0 : _b$getMainEntry.meta.webextEntry) === true;
      });
      const entry = manifest === null || manifest === void 0 ? void 0 : manifest.getMainEntry();
      const insertDep = entry === null || entry === void 0 ? void 0 : entry.meta.webextBGInsert;
      if (!manifest || !entry || insertDep == null) return;
      const insertBundle = bundleGraph.getReferencedBundle((0, _nullthrows().default)(entry === null || entry === void 0 ? void 0 : entry.getDependencies().find(dep => dep.id === insertDep)), (0, _nullthrows().default)(manifest));
      let firstInsertableBundle;
      bundleGraph.traverseBundles((b, _, actions) => {
        if (b.type == 'js') {
          firstInsertableBundle = b;
          actions.stop();
        }
      }, insertBundle);

      // Add autoreload
      if (bundle === firstInsertableBundle) {
        return [{
          filePath: __filename,
          code: AUTORELOAD_BG,
          isEntry: true
        }, {
          filePath: __filename,
          // cache bust on non-asset manifest.json changes
          code: `JSON.parse(${JSON.stringify(JSON.stringify(JSON.parse((0, _utils().replaceURLReferences)({
            bundle: manifest,
            bundleGraph,
            contents: await entry.getCode(),
            getReplacement: () => ''
          }).contents)))})`,
          isEntry: true
        }];
      }
    }
  }
});